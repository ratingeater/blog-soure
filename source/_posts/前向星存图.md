---
title: 邻接表存图
date: 2018-05-03 22:13:56
tags: [图论,笔记]
---


为什么要用邻接表存图？

邻接表可以很方便地读取点的出边，在某些图论算法（如SPFA）中可以做到很低地复杂度

FlyuZ：邻接表是用链表实现的，可以动态的增加边， 而链式前向星是用结构体数组实现的，是静态的，需要一开始知道数据范围，开好数组大小。 相比之下，邻接表灵活，但链式前向星好写。

<!--more-->

# 准备工作

> last[x]是点的头指针
>
> e[i].next是链表的下一个元素
>
> e[i].to是这一个点所到达的边，e[i].v是这条边的权值





# 建立边表

```cpp
last[MAXN];
struct edge{
	int to,next,v;
}e[MAXN];
```

# 加边的方法

```cpp
void add(int u,int v,int w){
	cnt++;
	e[cnt].to=v;
	e[cnt].next=last[u];
	last[u]=cnt;
	e[cnt].v=w;
}
```

## 原理

cnt记录的是当前点的序号，后面所有e的操作都是在cnt内的。

将cnt的边的终点指向v。

将下一个元素连到起点u的头指针并更新u的头指针。

最后记录边权，这一步可有可无。

# 遍历的方法

```cpp
for(int i=last[now];i!=0;i=e[i].next){
	//Do something
}
```

从now的头元素开始沿着链表遍历全图。


# 效率对比

| 方式 | 查询（出边） | 插入 |
| - | :-: | :-: |
| 邻接矩阵 | $\Theta(n)$ | $\Theta(1)$ |
| 邻接表 | $\Theta(k)$ | $\Theta(3)$ |

_注：上图中的k指的是所连出边_

也就是说，如果在一个完全图（任何一点与所有点都有连边）中，邻接表与邻接矩阵几乎是一样的。

